\documentclass[11pt]{article}
\include{preamble} %% Separate file for preamble with macros and stuff


%% Title
\title{Laboration 1: PID-controls\\ {\small Sensors and Sensing}}
\author{Michael Flo{\ss}mann, Tom Olsson}
\date{\today}

\begin{document}
\maketitle %Title area
\listoffigures % List of all figures
\lstlistoflistings % List of all code snippets
\lstset{ matchrangestart=t} %initialise the linerange-macro for \lstinput...
\section{Theory and motivation}
Control algorithms are important to create predictable, safe, and reliable operation in robotics applications. Two important algorithms/controllers for this purpose is the \emph{PID-controller} and the \emph{mimimum jerk trajectory}. 

\subsection{PID controller}
PID in the name PID-controller is short for \emph{P}roportional-\emph{Integral}-\emph{Derivative}-controller. As this implies, the controlling signal is based on a proportion of the current value, the previous values, and the rate of change of the observed value. The mathemathical formulation of this can be seen in \vref{eq:pid}.\par \vspace{10pt}
{\footnotesize
  \begin{tabular}{l l l}
    \textbf{Let:} \\
 &$e(t)$ &be some error measurement between current state and preferred state\\
 &$\di{K}{p}$, $\di{K}{i}$, $\di{K}{d}$ &be the respective weights for the proportional, integral and derivate terms \\
 &$u(t)$ &be the output signal at time \emph{t} \\
    \textbf{Then:}
  \end{tabular}
  \begin{align}
    u(t) &= \di{K}{p}\cdot e(t) + \di{K}{i} \cdot\int_{0}^{t}e(\tau)\cdot \dif\tau + \di{K}{d} \cdot \od{e(t)}{t}\label{eq:pid}
  \end{align}}
\par

\subsection{Minimum jerk}
The minimum jerk equation is an important part of creating smooth control. When a rotating actuator such as a motor starts, both the rotor and the stator will be at rest. The momentum generated by the motor can therefore cause movement in either part. As this can create an unwanted jerk while the rotor accelerates, it is important to accelerate slowly so that the stator remains at rest in relation to the reference frame. This can be achieved by the \emph{minimum jerk equation} shown in \vref{eq:mje}.
\par \vspace{10pt}
{\footnotesize
  \begin{tabular}{l l l}
    \textbf{Let:} \\
 &$\di{x}{i}$, $\di{x}{f}$ &be the initial and final states\\
 &$t$, $T$ &be the elapsed time since the action started, and the preferred total time for the action  \\
 &$x(t)$ &be the estimated state at time \emph{t} \\
    \textbf{Then:}
  \end{tabular}
  \begin{align}
    x(t) &= \di{x}{i} +  (\di{x}{f} - \di{x}{i}) \cdot \left[10\left(\frac{t}{T}\right)^3 - 15\left(\frac{t}{T}\right)^4 + 6\left(\frac{t}{T}\right)^6 \right]\label{eq:mje}          
  \end{align}}

The $T$ parameter has to be estimated. If $T$ is much larger than  the actual time that is needed for the trajectory, the velocity will be very low, and if $T$ is too low $x(t)$ will approach infinity unless $\frac{t}{T}$ is clamped to $[0,1]$. However, this solution is not optimal. Instead, we choose to calculate the optimal time $\di{T}{opt}$ as follows.%, and this can be seen in \ref{eq:derivative}.
\par
For finding out the optimal time $\di{T}{opt}$, we substitute:
\begin{align}
  \label{eq:tau_substitution}
  \tau:=\frac{t}{T}
\end{align}\vspace{-26pt}
\begin{align}
\ref{eq:mje}\Rightarrow x(\tau)&= \di{x}{i} +  (\di{x}{f} - \di{x}{i}) \cdot \left(10\tau^3 - 15\tau^4 + 6\tau^6 \right)\\
\od{x(\tau)}{\tau}&= (\di{x}{f} - \di{x}{i})\cdot(30\tau^2-60\tau^3+36\tau^5)\label{eq:dx_dtau}
\end{align}
\ref{eq:dx_dtau} reaches its' maximum at $\tau=0.5$ (proof trivial) with the value:
\begin{align}
  \eval{\od{x(\tau)}{\tau}}_{\tau=0.5}&=\frac{15}{18}\cdot(\di{x}{f} - \di{x}{i})
\end{align}
In order to make this term dependent on $T$, we must resubstitute:
\begin{align}
  \ref{eq:tau_substitution}&\Rightarrow %\od{\tau}{t}
\dot{\tau}
=\frac{1}{T}\\
  &\Rightarrow\dif\tau=\dif t\cdot\frac{1}{T}\label{eq:dtau_resubs}\\
  \ref{eq:dx_dtau},\ref{eq:dtau_resubs}&\Rightarrow%\eval{T\cdot\od{x(\tau)}{t}}_{\tau=0.5}=\frac{15}{18}\cdot(\di{x}{f} - \di{x}{i})\\
%  &\Rightarrow
\eval{\od{x(\tau)}{t}}
%\dot{\tau}}
_{\tau=0.5}=\frac{15}{18}\cdot\frac{\di{x}{f} - \di{x}{i}}{T}\label{eq:dx_dt}
\end{align}
Now, if we state an optimal maximum velocity $\di{v}{opt}$ for the minimum jerk equation, we can calculate the optimal time $\di{T}{opt}$ for this velocity:
\begin{align}
  \Rightarrow&\eval{\od{x(\tau)}{t}}_{\tau=0.5}=\di{v}{opt}\\
  \ref{eq:dx_dt}\Rightarrow& \di{T}{opt}=\frac{15}{18}\cdot\frac{\di{x}{f} - \di{x}{i}}{\di{v}{opt}}
\end{align}
\par

\section{Implementation}
The purpose of this exercise is to implement a PID-controller using the minimum jerk trajectory, and use this implementation for both a \emph{set-position} mode of operation, as well as a \emph{set-velocity} mode of operation. An important part of this exercise is the tuning of the PID-parameters for either mode of operation. \par

\subsection{Hardware and environment}
The laboration is performed using an \emph{Arduino Due} microcontroller, with the \emph{Arduino Motor Shield R3}. These are programmed using Serial-over-USB; with the dedicated IDE. The version of the IDE used is 1.6.5. The exercise also includes usage of the \emph{Robot Operating System} [ROS], and the \emph{Indigo} version was used. \par

The motor used is the \emph{Micro Motors RHE158 75:1 12V DC}, connected to the motor shield. As the USB-bus cannot supply enough power to drive the motor, an external 12V power adapter was used. 
\subsection{Position controller}
The first part of the position is the callback for setting a target position. This code is shown in listing \vref{lst:position-callback}. The code updates the mode of operation, and sets the start and end position for the movement. The integral term of the controller is also set to zero. Tests were made without setting it to zero, but this caused unreliable behaviour in some situations, such as when the target position was moved closer to the current position. \par

As can be seen on line TODO, the derivative from section \vref{sec:mje} is used to calculate the end time point. This ensures that we  reach the maximum speed at $\frac{t}{T} = 0.5$. While this is suboptimal for long trajectories, it makes sure that $T$ is realistic for shorter paths. If long trajectories will be the normal mode of operation; an approach with splines should be used instead. \par

\lstinputlisting[label=lst:position-callback,caption={Set Position Callback}, linerange={298-312}]{../lab1_stub/lab1_stub.ino}

The position controller is implemented to setup the parameters for PID and MJE. The code for this can be see in listing \vref{lst:position-controller}. The minimum jerk function is called with start-time, current time, and end-time, as well as start and end position. The output of this equation is then used to calculate the momentary error, as well as its derivative. These are then given to the PID-controller. \par

\lstinputlisting[label=lst:position-controller,caption=Position Controller ,firstline=225,lastline=252,firstnumber=225]{../lab1_stub/lab1_stub.ino}

\subsection{Velocity controller}
As with the position controller, an important part of the velocity controller is the callback for setting the target velocity. This code is shown in listing \vref{lst:velocity-callback}. The only difference to the position callback is the $T$ parameter. This was tested to see the minimum acceptable time to go from full forward speed to full reverse speed, and 3 seconds seemed to be a reasonable value. As the difference in speed is 560 ticks per second; this therefore becomes $\left\lceil\frac{3}{560}\right\rceil _4 = 0.006$. \par

\lstinputlisting[label=lst:velocity-callback,caption=Set Velocity Callback ,firstline=342,lastline=355,firstnumber=342]{../lab1_stub/lab1_stub.ino}

The velocity controller is also very similar to the position controller, as can be seen in listing \vref{lst:velocity-controller}. As before, the minimum jerk function is called with start-time, current time, and end-time. However, the last two parameters are replaced by  start and end velocity. As can be seen on line TODO the momentary velocity is smoothed using a sliding integral, and normalized to seconds. The reason for this is that the maximum speed of the motor is 235 ticks per second, while the program operates at 1 kHz. The general rule therefore is that no encoder ticks will happen during one program cycle, therefore causing the momentary speed to be measured as 0. After this, the velocity controller continues as the position controller

\lstinputlisting[label=lst:velocity-controller,caption=Velocity Controller ,firstline=263,lastline=283,firstnumber=263]{../lab1_stub/lab1_stub.ino}

\subsection{PID-controller, minimum jerk and actuation}
The PID-controller used before matches the equation shown earlier in \vref{eq:pid}. The implementation is shown in listing \vref{lst:pid}.

\lstinputlisting[label=lst:pid,caption=PID-implementation ,firstline=292,lastline=304,firstnumber=292]{../lab1_stub/lab1_stub.ino}

The mimimum jerk equation is also implemented as shown earlier  in \vref{eq:mje}. The only difference is that the fraction $\frac{t}{T}$ is clamped to $[0,1]$. Though this should not be needed with the guarantees made by the calculations of $T$, it was put in as a safeguard. Otherwise, a delayed controller can potentially accumulate an infinite error can lose control. The code for this can be seen in listing \vref{lst:mje}.\par

\lstinputlisting[label=lst:mje,caption=Mimimum jerk implementation ,firstline=285,lastline=290,firstnumber=285]{../lab1_stub/lab1_stub.ino}

Lastly, the actuation function is what actually transforms the control value into a PWM output. The function receives the output from the PID-controller, and clamps it to the allowed range as well as setting the direction of the motor. The code for this can be seen in listing \vref{lst:actuate}.

\lstinputlisting[label=lst:actuate,caption=Actuator implementation ,firstline=222,lastline=231,firstnumber=222]{../lab1_stub/lab1_stub.ino}


\section{Verification and results}
\subsection{PID-tuning}
The tuning of the PID-controller was done in three steps. First, the $k_p$ term was found with which reasonable behaviour was seen. Then, the $k_i$ term was estimated to be on the order of $\num{1e-6}$, based on $dT=1000$. This follows from the definition of the integral. When a good value was found, the derivative term was increased and was estimated to be on the order of magnitude $\num{1e0}$. This follows from the definition of the derivative term and the timestep. Lastly, several tests were ran with the final configuration to make sure that no erroneous behaviour was occuring. \par

After testing, the values $k_p = 60$, $k_i = \num{1e-6}$, and $k_d = 2$ was found to provide the best performance. These parameters were found to provide good results for both velocity and position control. Plots of the behaviours can be seen in figs. \ref{fig:pos} and \vref{fig:vel}. \par

\begin{figure}[h]
  \begin{subfigure}[b]{.45\textwidth}
    \includegraphics[width=.5\textwidth]{figures/posplot.png}
    \caption{Plot of position=bla bla bla}\label{fig:pos}
  \end{subfigure} 
  \begin{subfigure}[b]{.45\textwidth}
    \includegraphics[width=.5\textwidth]{figures/velplot.png}
    \caption{Plot of velocity = bla bla bla.}    \label{fig:ve}
  \end{subfigure}
  \captionof{figure}[Plots of controller behaviour]{Plots of controller behaviour for some target values. Asymptote lines added for clarity.}
\end{figure}
\subsection{Results}

\end{document}





%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
